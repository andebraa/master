# Boilerplate code generated by OVITO Pro 3.5.4
import json
import numpy as np
import re
#from post_utils import get_erratic_contact_area #ovitos doesn't like this, copied erratic_contact area in here instead
from ovito.io import import_file, export_file
from ovito.modifiers import *
from ovito.pipeline import *
from glob import glob
from numpy import savetxt, asarray
from tqdm import trange
from scipy.signal import find_peaks
from scipy.constants import value
from lammps_logfile import File, running_mean
import warnings
import json


orientation = 100
height = 115 # Å 
force = 0.001 #eV/Å
grid = (3,3)
time = 1000 #ps
delta = time/1e6
temp = 2300



# paths
project_dir = '../../'
relax_dir = project_dir + 'simulations/sys_or{}_hi{}/relax/'
area_relax_dir = project_dir + 'txt/area_relax/'
coordination_dir = project_dir + 'txt/coordination/'


template_dump = relax_dir + 'sim_temp{}_force{}_time{}_seed*_errgrid{}_{}/dump.bin'
auxiliary_dir = project_dir + 'initial_system/erratic/aux/system_or{}_hi{}_errgrid{}_{}_auxiliary.json'
template_area = area_relax_dir + 'areas_temp{}_force{}_55_hi{}_seed{}_erratic{}_{}'#add the txt in count_coord
template_coord = coordination_dir + 'coordination_temp{}_force{}_hi{}_seed{}_erratic{}_{}'


with open(auxiliary_dir.format(orientation, height, grid[0], grid[1])) as auxfile:
    data = auxfile.read()
args = json.loads(data)

#data import
dumpfile = glob(template_dump.format(orientation, height, temp, force, time, grid[0], grid[1]))
print(len(dumpfile))
pipeline = import_file(dumpfile, multiple_frames = True)


# Slice z-dir (around contact point):
pipeline.modifiers.append(SliceModifier(
    distance = 55.0, 
    normal = (0.0, 0.0, 1.0), 
    slab_width = 2.0))

# Cluster analysis:
pipeline.modifiers.append(ClusterAnalysisModifier(
    sort_by_size = True))

# Expression selection:
pipeline.modifiers.append(ExpressionSelectionModifier(expression = 'Cluster!=1'))

# Delete selected:
pipeline.modifiers.append(DeleteSelectedModifier())

# Slice on 2D-grid
lx = args['sys_lx']   # Å
ly = args['sys_ly']   # Å
nx = args['grid'][0]
ny = args['grid'][1]
lx_slice = lx / nx
ly_slice = ly / ny

print('is similar', lx_slice == args['lx']) # check if lx/nx and lx from args is similar
print('is similar', ly_slice == args['ly'])


bool_grid = np.array(args['erratic'])
for i in range(nx):
    for j in range(ny):
        # Slice x-dir (midpoint, default settings):
        pipeline.modifiers.append(SliceModifier(
            normal = (1.0, 0.0, 0.0),
            distance = (i+0.5) * lx_slice,
            slab_width = lx_slice))

        # Slice y-dir (midpoint):
        pipeline.modifiers.append(SliceModifier(
            normal = (0.0, 1.0, 0.0),
            distance = (j+0.5) * ly_slice,
            slab_width = ly_slice))

        # Construct surface mesh:
        pipeline.modifiers.append(ConstructSurfaceModifier(
            radius = 20.0)) 
            #identify_regions=True))
    
        export_file(pipeline, 'test_block_temp{}{}'.format(i,j), 'lammps/data', atom_style = 'atomic')
        # Output surface area as a function of time
        nums, areas = [], []
        for i in trange(pipeline.source.num_frames):
            data = pipeline.compute(frame=i)
            nums.append(data.attributes['ClusterAnalysis.largest_size'])
            # divid area by 2 to find area of one surface and by 100 to go from Å² to nm²
            areas.append(data.attributes['ConstructSurfaceMesh.surface_area'] / 200)
            #print(nums[-1])
            #print(areas[-1])

        # delete modifiers
        del pipeline.modifiers[-1]
        del pipeline.modifiers[-1]
        del pipeline.modifiers[-1]

del pipeline
